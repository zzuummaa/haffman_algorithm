# Кодировщик на основе алгоритма Хаффмана

Позволяет кодировать/декодировать бинарные файлы

## Реализация

Кодирование происходит с помощью двух проходов по файлу. Во время первого- подсчитываются частоты появления символов и
строится дерево с вероятностями в узлах и символами в листьях. Далее по дереву во время второго прохода по исходному файлу
кодируются символы. Биты кодируются в обратном порядке при движении от листа к корню. Поэтому после успешного
кодирования очередного символа его биты переворачиваются.

Декодирование происходит с помощью того же дерева, только движение осущетсвляется от корня к листьям.

## Как повысить производительность кода

1. Преобразовать дерево в ассоциативный массив. С одной стороны это откроет путь для оптимизаций операций над битами.
С другой стороны ассоциативный массив можно реализовать более компактно, чем дерево. Теоретически, дерево в текущем виде
(10-20Кб) может не поместиться в L1(16-32Кб) кэш процессора. Это может отрицательно влиять на производительность.

2. Использовать операции над 8-64 битовыми ячейками памяти вместо побитового копирования и сравнения.

## Формат закодированного файла

В начало закодированного файла помещается заголовок с информацией для декодирования, содержащий множество символов
кодируемого файла и их частоты (количество вхождений данного символа / количество символов в файле). Затем располагается
закодированная последовательность символов. В конце она дополняется битами до целого байта. Последний байт файла
содержит количество дополняющих бит.

| Описание поля                          | Количество бит               | Тип данных                |
| -------------------------------------- |:----------------------------:|:-------------------------:|
| Количество уникальных символов (N)     | 16                           | uint16                    |
| Кодируемый символ + его частота        | (8 + 64) х N                 | (uint8_t + double) x N    |
| Закодированные символы исходного файла | K                            |                           |
| Дополнение до конца байта              | K % 8 == 0 ? 0 : 8 - (K % 8) |                           |
| Количество дополняющих битов           | 8                            | uint8_t                   |

